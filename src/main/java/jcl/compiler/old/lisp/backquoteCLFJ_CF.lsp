;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BACKQUOTE MACROS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Now we switch to the backquote macro. Good idea to have it now since
;;; many of the following functions and macros rely on it...
;;; NOTE: we switch packages here also. We switch back a little later.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun atom-or-string (x)
  (if (atom x)
      t
    (stringp x)))

(setq *comma*          (make-symbol "COMMA"))          (system::%set-special '*comma* t)
(setq *comma-atsign*   (make-symbol "COMMA-ATSIGN"))   (system::%set-special '*comma-atsign* t)
(setq *comma-dot*      (make-symbol "COMMA-DOT"))      (system::%set-special '*comma-dot* t)
(setq *bq-list*        (make-symbol "BQ-LIST"))        (system::%set-special '*bq-list* t)
(setq *bq-append*      (make-symbol "BQ-APPEND"))      (system::%set-special '*bq-append* t)
(setq *bq-list**       (make-symbol "BQ-LIST*"))       (system::%set-special '*bq-list** t)
(setq *bq-nconc*       (make-symbol "BQ-NCONC"))       (system::%set-special '*bq-nconc* t)
(setq *bq-clobberable* (make-symbol "BQ-CLOBBERABLE")) (system::%set-special '*bq-clobberable* t)
(setq *bq-quote*       (make-symbol "BQ-QUOTE"))       (system::%set-special '*bq-quote* t)
(setq *bq-quote-nil*   (list *bq-quote* nil))          (system::%set-special '*bq-quote-nil* t)

;;; Reader macro characters:
;;;    $foo is read in as (BACKQUOTE foo)
;;;    %foo is read in as (#:COMMA foo)
;;;    %@foo is read in as (#:COMMA-ATSIGN foo)
;;;    %.foo is read in as (#:COMMA-DOT foo)
;;; where #:COMMA is the value of the variable *COMMA*, etc.

;;; BACKQUOTE is an ordinary macro (not a read-macro) that
;;; processes the expression foo, looking for occurrences of
;;; #:COMMA, #:COMMA-ATSIGN, and #:COMMA-DOT.  It constructs code
;;; in strict accordance with the rules on pages 349-350 of
;;; the first edition (pages 528-529 of this second edition).
;;; It then optionally applies a code simplifier.

(set-macro-character #\`
  #'(lambda (char stream)
      (list 'backquote (read stream t nil t))))


(set-macro-character #\,
  #'(lambda (char stream)
      (let ((val (peek-char nil stream t nil t)))
        (if (eql val #\@)
            (progn
              (read-char stream t nil t)
              (list *comma-atsign* (read stream t nil t)))
          (if (eql val #\.)
              (progn
                (read-char stream t nil t)
                (list *comma-dot* (read stream t nil t)))
            (progn
              (list *comma* (read stream t nil t))))))))

;;; If the value of *BQ-SIMPLIFY* is non-NIL, then BACKQUOTE
;;; processing applies the code simplifier.  If the value is NIL,
;;; then the code resulting from BACKQUOTE is exactly that
;;; specified by the official rules.

(setq *bq-simplify* NIL)
(system::%set-special '*bq-simplify* t)

;-------

(defmacro backquote (whole env)
  (bq-completely-process (car (cdr whole))))

;;; Backquote processing proceeds in three stages:
;;;
;;; (1) BQ-PROCESS applies the rules to remove occurrences of
;;; #:COMMA, #:COMMA-ATSIGN, and #:COMMA-DOT corresponding to
;;; this level of BACKQUOTE.  (It also causes embedded calls to
;;; BACKQUOTE to be expanded so that nesting is properly handled.)
;;; Code is produced that is expressed in terms of functions
;;; #:BQ-LIST, #:BQ-APPEND, and #:BQ-CLOBBERABLE.  This is done
;;; so that the simplifier will simplify only list construction
;;; functions actually generated by BACKQUOTE and will not involve
;;; any user code in the simplification.  #:BQ-LIST means LIST,
;;; #:BQ-APPEND means APPEND, and #:BQ-CLOBBERABLE means IDENTITY
;;; but indicates places where "%." was used and where NCONC may
;;; therefore be introduced by the simplifier for efficiency.
;;;
;;; (2) BQ-SIMPLIFY, if used, rewrites the code produced by
;;; BQ-PROCESS to produce equivalent but faster code.  The
;;; additional functions #:BQ-LIST* and #:BQ-NCONC may be
;;; introduced into the code.
;;;
;;; (3) BQ-REMOVE-TOKENS goes through the code and replaces
;;; #:BQ-LIST with LIST, #:BQ-APPEND with APPEND, and so on.
;;; #:BQ-CLOBBERABLE is simply eliminated (a call to it being
;;; replaced by its argument).  #:BQ-LIST* is replaced by either
;;; LIST* or CONS (the latter is used in the two-argument case,
;;; purely to make the resulting code a tad more readable).

(defun bq-completely-process (x)
  (let ((raw-result (bq-process x)))
    (bq-remove-tokens (if *bq-simplify*
                          (bq-simplify raw-result)
                        raw-result))))

(defun bq-process (x)
  (if (atom-or-string x)
      (list *bq-quote* x)
    (if (eq (car x) 'backquote)
        (bq-process (bq-completely-process (car (cdr x))))
      (if (eq (car x) *comma*)
          (car (cdr x))
        (if (eq (car x) *comma-atsign*)
            (error ",@~S after `" (car (cdr x)))
          (if (eq (car x) *comma-dot*)
              (error ",.~S after `" (car (cdr x)))
            (let ((p x)
                  (q nil))
              (tagbody
                top
                (if (atom-or-string p)
                    (go out)
                  (progn
                    (if (eq (car p) *comma*)
                        (progn
                          (if (cdr (cdr p))
                              (error "Malformed ,~S" p))
                          (return-from bq-process (cons *bq-append* (nreconc q (list (car (cdr p))))))))
                    (if (eq (car p) *comma-atsign*)
                        (error "Dotted ,@~S" p))
                    (if (eq (car p) *comma-dot*)
                        (error "Dotted ,.~S" p))
                    (setq q (cons (bracket (car p)) q))
                    (setq p (cdr p))
                    (go top)))
                out)
              (cons *bq-append* (nreconc q (list (list *bq-quote* p)))))))))))

;;; This implements the bracket operator of the formal rules.
(defun bracket (x)
  (if (atom-or-string x)
      (list *bq-list* (bq-process x))
    (if (eq (car x) *comma*)
        (list *bq-list* (car (cdr x)))
      (if (eq (car x) *comma-atsign*)
          (car (cdr x))
        (if (eq (car x) *comma-dot*)
            (list *bq-clobberable* (car (cdr x)))
          (list *bq-list* (bq-process x)))))))

;;; This auxiliary function is like MAPCAR but has two extra
;;; purposes: (1) it handles dotted lists; (2) it tries to make
;;; the result share with the argument x as much as possible.
(defun maptree (fn x)
  (if (atom-or-string x)
      (funcall fn x)
    (let ((a (funcall fn (car x)))
          (d (maptree fn (cdr x))))
      (if (if (eql a (car x))
              (eql d (cdr x)))
          x
        (cons a d)))))

;;; This predicate is true of a form that when read looked
;;; like %@foo or %.foo.
(defun bq-splicing-frob (x)
  (if (consp x)
      (if (eq (car x) *comma-atsign*)
          *comma-atsign*
        (if (eq (car x) *comma-dot*)
            *comma-dot*))))

;;; This predicate is true of a form that when read
;;; looked like %@foo or %.foo or just plain %foo.
(defun bq-frob (x)
  (if (consp x)
      (if (eq (car x) *comma*)
          *comma*
        (if (eq (car x) *comma-atsign*)
            *comma-atsign*
          (if (eq (car x) *comma-dot*)
              *comma-dot*)))))

;;; The simplifier essentially looks for calls to #:BQ-APPEND and
;;; tries to simplify them.  The arguments to #:BQ-APPEND are
;;; processed from right to left, building up a replacement form.
;;; At each step a number of special cases are handled that,
;;; loosely speaking, look like this:
;;;
;;;  (APPEND (LIST a b c) foo) => (LIST* a b c foo)
;;;       provided a, b, c are not splicing frobs
;;;  (APPEND (LIST* a b c) foo) => (LIST* a b (APPEND c foo))
;;;       provided a, b, c are not splicing frobs
;;;  (APPEND (QUOTE (x)) foo) => (LIST* (QUOTE x) foo)
;;;  (APPEND (CLOBBERABLE x) foo) => (NCONC x foo)
(defun bq-simplify (x)
  (if (atom-or-string x)
      x
      (let ((x (if (eq (car x) *bq-quote*)
                   x
                 (maptree #'bq-simplify x))))
        (if (not (eq (car x) *bq-append*))
            x
          (bq-simplify-args x)))))

(defun bq-simplify-args (x)
  (let ((args (system::%reverse (cdr x)))
        (result nil))
    (tagbody
      top
      (if (null args)
          (go out)
        (progn
          (setq result
		          (if (atom-or-string (car args))
		              (bq-attach-append *bq-append* (car args) result)
		            (if (if (eq (caar args) *bq-list*)
		                    (notany #'bq-splicing-frob (cdar args)))
		                (bq-attach-conses (cdar args) result)
		              (if (if (eq (caar args) *bq-list**)
		                      (notany #'bq-splicing-frob (cdar args)))
		                  (bq-attach-conses
		                      (system::%reverse (cdr (system::%reverse (cdar args))))
		                      (bq-attach-append *bq-append* (car (last (car args))) result))
		                (if (if (eq (caar args) *bq-quote*)
		                        (if (consp (cadar args))
		                            (if (not (bq-frob (cadar args)))
		                                (null (cddar args)))))
		                    (bq-attach-conses (list (list *bq-quote* (caadar args))) result)
		                  (if (eq (caar args) *bq-clobberable*)
		                      (bq-attach-append *bq-nconc* (cadar args) result)
		                    (bq-attach-append *bq-append* (car args) result)))))))
          (setq args (cdr args))
          (go top)))
      out
      result)))

(defun null-or-quoted (x)
  (if (null x)
      t
    (if (consp x)
        (eq (car x) *bq-quote*))))

;;; When BQ-ATTACH-APPEND is called, the OP should be #:BQ-APPEND
;;; or #:BQ-NCONC.  This produces a form (op item result) but
;;; some simplifications are done on the fly:
;;;
;;;  (op '(a b c) '(d e f g)) => '(a b c d e f g)
;;;  (op item 'nil) => item, provided item is not a splicable frob
;;;  (op item 'nil) => (op item), if item is a splicable frob
;;;  (op item (op a b c)) => (op item a b c)
(defun bq-attach-append (op item result)
  (if (if (null-or-quoted item)
          (null-or-quoted result))
      (list *bq-quote* (append (car (cdr item)) (car (cdr result))))
    (if (if (null result)
            t
          (equal result *bq-quote-nil*))
        (if (bq-splicing-frob item)
            (list op item)
          item)
      (if (if (consp result)
              (eq (car result) op))
          (list* (car result) item (cdr result))
        (list op item result)))))

;;; The effect of BQ-ATTACH-CONSES is to produce a form as if by
;;; `(LIST* ,@items ,result) but some simplifications are done
;;; on the fly.
;;;
;;;  (LIST* 'a 'b 'c 'd) => '(a b c . d)
;;;  (LIST* a b c 'nil) => (LIST a b c)
;;;  (LIST* a b c (LIST* d e f g)) => (LIST* a b c d e f g)
;;;  (LIST* a b c (LIST d e f g)) => (LIST a b c d e f g)
(defun bq-attach-conses (items result)
  (if (if (system::%every #'null-or-quoted items)
          (null-or-quoted result))
      (list *bq-quote* (append (system::%mapcar #'cadr items) (car (cdr result))))
    (if (if (null result)
            t
          (equal result *bq-quote-nil*))
        (cons *bq-list* items)
      (if (if (consp result)
              (if (eq (car result) *bq-list*)
                  t
                (eq (car result) *bq-list**)))
          (cons (car result) (append items (cdr result)))
        (cons *bq-list** (append items (list result)))))))

;;; Removes funny tokens and changes (#:BQ-LIST* a b) into
;;; (CONS a b) instead of (LIST* a b), purely for readability.
(defun bq-remove-tokens (y)
   (if (eq y *bq-list*)
       'list
     (if (eq y *bq-append*)
         'append
       (if (eq y *bq-nconc*)
           'nconc
         (if (eq y *bq-list**)
             'list*
           (if (eq y *bq-quote*)
               'quote
             (if (atom-or-string y)
                 y
               (if (eq (car y) *bq-clobberable*)
                   (bq-remove-tokens (cadr y))
                 (if (if (eq (car y) *bq-list**)
                         (if (consp (cddr y))
                             (null (cdddr y))))
                     (cons 'cons (maptree #'bq-remove-tokens (cdr y)))
                   (maptree #'bq-remove-tokens y))))))))))
