UNWIND-PROTECT:

(deftest unwind-protect.6
  (let ((x nil))
    (block done
      (flet ((%f () (return-from done nil)))
        (unwind-protect (%f)
          (setq x '(a)))))
    x)
  (a))

(deftest unwind-protect.7
  (let ((x nil))
    (block done
      (flet ((%f () (return-from done nil)))
        (unwind-protect
            (unwind-protect (%f)
              (setq x '(b)))
          (setq x '(a)))))
    x)
  (a b))

(deftest unwind-protect.8
  (let ((x nil))
    (block done
      (unwind-protect
          (flet ((%f () (return-from done nil)))
            (unwind-protect
                (unwind-protect (%f)
                  (setq x '(b)))
              (setq x '(a))))
        (setq x '(c))))
    x)
  (c a b))

(deftest unwind-protect.9
  (let ((x nil))
    (handler-case
      (flet ((%f () (error 'type-error :datum 'foo :expected-type nil)))
        (unwind-protect (handler-case (%f))
          (setq x '(a))))
      (type-error () x)))
  (a))

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
TAGBODY:

(deftest tagbody.8
  (let ((x 0))
    (tagbody
     (flet ((%f (y) (setq x y) (go a)))
       (%f 10))
     (setq x 1)
     a)
    x)
  10)

(deftest tagbody.9
  (let (result)
    (tagbody
     (flet ((a (x) x))
       (setq result (a 10))
       (go a))
     a)
    result)
  10)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
BLOCK:

(deftest block.10
  (block done
    (flet ((%f (x) (return-from done x)))
      (block done (mapcar #'%f '(good bad bad))))
    'bad)
  good)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
THROW:

(deftest throw-error
  (signals-error (throw (gensym) nil) control-error)
  t)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
PROGV:

(deftest progv.1
  (progv () () t)
  t)

(progv (x) (1) x)
> Error: While compiling an anonymous function :
>        In the form (1), 1 is not a symbol or lambda expression., in process Listener(4).

(let ((x 0) (y 0) (c 0))
    (progv
        (progn (setq x (setq c 1)) nil)
        (progn (setq y (setq c 2)) nil)
      (values x y c)))

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
LET:

(deftest let.5
  (let ((x 0))
    (let ((#:x 1))
      x))
  0)

(deftest let.17a
  (funcall
   (compile
    nil
    '(lambda ()
       (let ((x :bad))
         (declare (special x))
         (let ((x :good)) ;; lexical binding
           (let ((y x))
             (declare (special x)) ;; free declaration
             y))))))
  :good)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
LET*:

(deftest let*.5
  (let* ((x 0))
    (let* ((#:x 1))
      x))
  0)

(deftest let*.13
  (flet ((%f () (declare (special x)) x))
    (let* ((x 1)
           (x (1+ (%f))))
      (declare (special x))
      x))
  2)

NOTE: This works fine, but we need to strip out CommentStructs at some point in the mix.
(deftest let*.17
  (let ((x :bad))
    (declare (special x))
    (let ((x :good)) ;; lexical binding
      (let* ((y x))
        (declare (special x)) ;; free declaration
        y)))
  :good)

(deftest let*.17a
  (funcall
   (compile
    nil
    '(lambda ()
       (let ((x :bad))
         (declare (special x))
         (let ((x :good)) ;; lexical binding
           (let* ((y x))
             (declare (special x)) ;; free declaration
             y))))))
  :good)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
LAMBDA:

(deftest lambda.54
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      ((lambda (&aux (y x)) (declare (special x)) y))))
  :good)

(deftest lambda.57
  ((lambda (#1=#:foo) #1#) 17)
  17)

(deftest lambda.58
  ((lambda (&rest #1=#:foo) #1#) 'a 'b 'c)
  (a b c))

(deftest lambda.59
  ((lambda (&optional #1=#:foo) #1#))
  nil)

(deftest lambda.60
  ((lambda (&optional (#1=#:foo t)) #1#))
  t)

(deftest lambda.61
  ((lambda (&optional (#1=#:foo t)) #1#) 'bar)
  bar)

(deftest lambda.62
  ((lambda (&key #1=#:foo) #1#) :foo 12)
  12)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
FLET:

(deftest flet.7
  (flet ((%f (x) x))
    (flet ((%f (y) (%f 20)))
      (%f 15)))
  20)

;;; Odd # of keyword args should throw a program-error in safe code
;;; (section 3.5.1.6)
(deftest flet.13
  (signals-error
   (flet ((%f (&key a (b 0 b-p)) (values a b (not (not b-p))))) (%f :a))
   program-error)
  t)

NOTE: The below works, but can we print the error better???
(deftest flet.16
  (signals-error (flet ((%f (&key a) a)) (%f '(foo))) program-error)
  t)

(deftest flet.17
  (flet (((setf %f) (x y) (setf (car y) x)))
    (let ((z (list 1 2)))
      (setf (%f z) 'a)
      z))
  (a 2))

(deftest flet.21
  (flet ((%f (x)
             (declare (type fixnum x))
             "Add one to the fixnum x."
             (1+ x)))
    (declare (ftype (function (fixnum) integer) %f))
    (%f 10))
  11)

(deftest flet.26
  (flet ((%f (x &optional (y 1 y-p) (z 2 z-p) &rest r &key foo bar)
             (list x y y-p z z-p r foo bar)))
    (values (%f 10) (%f 20 40) (%f 'a 'b 'c)
            (%f 'd 'e 'f :foo 'h :whatever nil :allow-other-keys t)
            (%f 'd 'e 'f :bar 'i :illegal t :foo 'z :allow-other-keys t) ))
  (10 1 nil 2 nil nil nil nil)
  (20 40 t 2 nil nil nil nil)
  (a b t c t nil nil nil)
  (d e t f t (:foo h :whatever nil :allow-other-keys t) h nil)
  (d e t f t (:bar i :illegal t :foo z :allow-other-keys t) z i))

(deftest flet.28
  (flet ((%f (x &optional (y 1 y-p) (z 2 z-p) &rest r
                &key foo bar allow-other-keys)
             (list x y y-p z z-p allow-other-keys
                   r foo bar)))
    (values (%f 10) (%f 20 40) (%f 'a 'b 'c)
            (%f 'd 'e 'f :foo 'h :whatever nil :allow-other-keys 100)
            (%f 'd 'e 'f :bar 'i :illegal t :foo 'z :allow-other-keys 200) ))
  (10 1 nil 2 nil nil nil nil nil)
  (20 40 t 2 nil nil nil nil nil)
  (a b t c t nil nil nil nil)
  (d e t f t 100 (:foo h :whatever nil :allow-other-keys 100) h nil)
  (d e t f t 200 (:bar i :illegal t :foo z :allow-other-keys 200) z i))

;;; Tests of non-keyword keywords (see section 3.4.1.4, paragrph 2).
(deftest flet.30
  (flet ((%f (&key ((foo bar) nil)) bar))
    (values (%f) (%f 'foo 10)))
  nil 10)

;;; Binding of formal parameters that are also special variables
(deftest flet.35
  (let ((x 'bad))
    (declare (special x))
    (flet ((%f () x))
      (flet ((%g (x)
                 (declare (special x))
                 (%f)))
        (%g 'good))))
  good)

(deftest flet.36
  (let ((x 'bad))
    (declare (special x))
    (flet ((%f () x))
      (flet ((%g (&aux (x 'good))
                 (declare (special x))
                 (%f)))
         (%g))))
  good)

(deftest flet.37
  (let ((x 'bad))
    (declare (special x))
    (flet ((%f () x))
      (flet ((%g (&rest x)
                 (declare (special x))
                 (%f)))
         (%g 'good))))
  (good))

(deftest flet.38
  (let ((x 'bad))
    (declare (special x))
    (flet ((%f () x))
      (flet ((%g (&key (x 'good))
                 (declare (special x))
                 (%f)))
         (%g))))
  good)

(deftest flet.39
  (let ((x 'bad))
    (declare (special x))
    (flet ((%f () x))
      (flet ((%g (&key (x 'bad))
                 (declare (special x))
                 (%f)))
         (%g :x 'good))))
  good)

;;; Keywords can be function names
(deftest flet.47
  (flet ((:foo () 'bar)) (:foo))
  bar)

(deftest flet.48
  (flet ((:foo () 'bar)) (funcall #':foo))
  bar)

;;; Check that nil keyword arguments do not enable the default values

(deftest flet.54
  (flet ((%f (&key (a 'wrong a-p)) (list a (not a-p)))) (%f :a nil))
  (nil nil))

(deftest flet.56
  (flet ((%f (&key ((:a b) 'wrong present?)) (list b (not present?)))) (%f :a nil))
  (nil nil))

(deftest flet.57
  (flet ((%f (&key) 'good))
    (%f :allow-other-keys nil))
  good)

(deftest flet.58
  (flet ((%f (&key) 'good))
    (%f :allow-other-keys t))
  good)

(deftest flet.59
  (flet ((%f (&key) 'good))
    (%f :allow-other-keys t :a 1 :b 2))
  good)

(deftest flet.62
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (flet ((%f (&optional (y x))
                 (declare (special x))
                 y))
        (%f))))
  :good)

(deftest flet.63
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (flet ((%f (&key (y x))
                 (declare (special x))
                 y))
        (%f))))
  :good)

(deftest flet.65
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (flet ((%f () (declare (special x)))))
      x))
  :good)

(deftest flet.66
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (flet ((%f () (declare (special x))))
        x)))
  :good)

(deftest flet.67
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (flet ((%f (&aux (y x))
                 (declare (special x))
                 y))
        (%f))))
  :good)

(deftest flet.69
  (let ((*x* 0))
    (declare (special *x*))
    (flet ((%f (i)
               #'(lambda (arg)
                   (declare (ignore arg))
                   (setq *x* i))))
      (values
       (funcall (%f 1) '(a b c))
       (funcall (%f 2) '(a b c))))))
  1 2)

// TODO: These next two need to be tested when we support macro-lambdas and compiler-macros.
(defmacro flet.73 () :bad)
(deftest flet.73
   (flet ((flet.73 () :good))
     (flet.73))
   :good)

(define-compiler-macro flet.74 (&whole form) :bad)
(deftest flet.74
   (flet ((flet.74 () :good))
     (flet.74))
   :good)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
LABELS:

// NOTE: Just need to figure out how to test this...
;;; The function is visible inside itself
(deftest labels.7
  (labels ((%f (x n) (cond ((eql n 0) x)
                           (t (%f (+ x n) (1- n))))))
    (%f 0 10))
  55)

// NOTE: for the next 2, &AUX works fine, but these don't. Use of LET for &AUX the reason why? Should we be using a LET for all init forms instead of SETQ'ing them? hmm....

;;; Scope of defined function names includes &OPTIONAL parameters
(deftest labels.7c
  (labels ((%f (x &optional (b (%g x))) b)
           (%g (y) (+ y y)))
    (%f 10))
  20)

;;; Scope of defined function names includes &KEY parameters
(deftest labels.7d
  (labels ((%f (x &key (b (%g x))) b)
           (%g (y) (+ y y)))
    (%f 10))
  20)

;;; Odd # of keyword args should throw a program-error in safe code
;;; (section 3.5.1.6)
(deftest labels.13
  (signals-error
   (labels ((%f (&key a (b 0 b-p)) (values a b (not (not b-p))))) (%f :a))
   program-error)
  t)

// NOTE: the following works, but can we print the message better???
;;; Invalid keyword argument (section 3.5.1.5)
(deftest labels.16
  (signals-error (labels ((%f (&key a) a)) (%f '(foo)))
                 program-error)
  t)

(deftest labels.17
  (labels (((setf %f) (x y) (setf (car y) x)))
    (let ((z (list 1 2)))
      (setf (%f z) 'a)
      z))
  (a 2))

;;; Declarations and documentation strings are ok
(deftest labels.21
  (labels ((%f (x)
             (declare (type fixnum x))
             "Add one to the fixnum x."
             (1+ x)))
    (declare (ftype (function (fixnum) integer) %f))
    (%f 10))
  11)

;;; Keywords can be function names
(deftest labels.22
  (labels ((:foo () 10)
           (:bar () (1+ (:foo))))
    (:bar))
  11)

(deftest labels.23
  (labels ((:foo () 10)
           (:bar () (1+ (funcall #':foo))))
    (funcall #':bar))
  11)

(deftest labels.29
  (labels ((%f (&key (a 'wrong a-p)) (list a (not a-p)))) (%f :a nil))
  (nil nil))

(deftest labels.31
  (labels ((%f (&key ((:a b) 'wrong present?)) (list b (not present?))))
    (%f :a nil))
  (nil nil))

(deftest labels.32
  (labels ((%f (&key) 'good))
    (%f :allow-other-keys nil))
  good)

(deftest labels.33
  (labels ((%f (&key) 'good))
    (%f :allow-other-keys t))
  good)

(deftest labels.34
  (labels ((%f (&key) 'good))
    (%f :allow-other-keys t :a 1 :b 2))
  good)

;;; Test that free declarations do not affect argument forms

(deftest labels.41
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (labels ((%f (&optional (y x))
                   (declare (special x))
                   y))
        (%f))))
  :good)

(deftest labels.42
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (labels ((%f (&key (y x))
                   (declare (special x))
                   y))
        (%f))))
  :good)

(deftest labels.44
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (labels ((%f () (declare (special x)))))
      x))
  :good)

(deftest labels.45
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (labels ((%f () (declare (special x))))
        x)))
  :good)

(deftest labels.46
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (labels ((%f (&aux (y x))
                   (declare (special x))
                   y))
        (%f))))
  :good)

// TODO: These next two need to be tested when we support macro-lambdas and compiler-macros.
(defmacro labels.51 () :bad)
(deftest labels.51
   (labels ((labels.51 () :good))
      (labels.51))
   :good)

(define-compiler-macro labels.52 (&whole form) :bad)
(deftest labels.52
   (labels ((labels.52 () :good))
     (labels.52))
   :good)
