UNWIND-PROTECT:

(deftest unwind-protect.6
  (let ((x nil))
    (block done
      (flet ((%f () (return-from done nil)))
        (unwind-protect (%f)
          (push 'a x))))
    x)
  (a))

(deftest unwind-protect.7
  (let ((x nil))
    (block done
      (flet ((%f () (return-from done nil)))
        (unwind-protect
            (unwind-protect (%f)
              (push 'b x))
          (push 'a x))))
    x)
  (a b))

(deftest unwind-protect.8
  (let ((x nil))
    (block done
      (unwind-protect
          (flet ((%f () (return-from done nil)))
            (unwind-protect
                (unwind-protect (%f)
                  (push 'b x))
              (push 'a x)))
        (push 'c x)))
    x)
  (c a b))

(deftest unwind-protect.9
  (let ((x nil))
    (handler-case
      (flet ((%f () (error 'type-error :datum 'foo :expected-type nil)))
        (unwind-protect (handler-case (%f))
          (push 'a x)))
      (type-error () x)))
  (a))

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
TAGBODY:

(deftest tagbody.8
  (let ((x 0))
    (tagbody
     (flet ((%f (y) (setq x y) (go a)))
       (%f 10))
     (setq x 1)
     a)
    x)
  10)

(deftest tagbody.9
  (let (result)
    (tagbody
     (flet ((a (x) x))
       (setq result (a 10))
       (go a))
     a)
    result)
  10)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
BLOCK:

(deftest block.10
  (block done
    (flet ((%f (x) (return-from done x)))
      (block done (mapcar #'%f '(good bad bad))))
    'bad)
  good)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
CATCH:

(deftest catch.10
  (flet ((%f (x) (throw 'foo x)))
    (catch 'foo
      (%f 'good)
      'bad))
  good)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
THROW:

(deftest throw-error
  (signals-error (throw (gensym) nil) control-error)
  t)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
PROGV:

(deftest progv.1
  (progv () () t)
  t)

(progv (x) (1) x)
> Error: While compiling an anonymous function :
>        In the form (1), 1 is not a symbol or lambda expression., in process Listener(4).

(let ((x 0) (y 0) (c 0))
    (progv
        (progn (setq x (setq c 1)) nil)
        (progn (setq y (setq c 2)) nil)
      (values x y c)))

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
LET:

(deftest let.5
  (let ((x 0))
    (let ((#:x 1))
      x))
  0)

(deftest let.17a
  (funcall
   (compile
    nil
    '(lambda ()
       (let ((x :bad))
         (declare (special x))
         (let ((x :good)) ;; lexical binding
           (let ((y x))
             (declare (special x)) ;; free declaration
             y))))))
  :good)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
LET*:

(deftest let*.5
  (let* ((x 0))
    (let* ((#:x 1))
      x))
  0)

(deftest let*.13
  (flet ((%f () (declare (special x)) x))
    (let* ((x 1)
           (x (1+ (%f))))
      (declare (special x))
      x))
  2)

NOTE: This works fine, but we need to strip out CommentStructs at some point in the mix.
(deftest let*.17
  (let ((x :bad))
    (declare (special x))
    (let ((x :good)) ;; lexical binding
      (let* ((y x))
        (declare (special x)) ;; free declaration
        y)))
  :good)

(deftest let*.17a
  (funcall
   (compile
    nil
    '(lambda ()
       (let ((x :bad))
         (declare (special x))
         (let ((x :good)) ;; lexical binding
           (let* ((y x))
             (declare (special x)) ;; free declaration
             y))))))
  :good)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
LAMBDA:

(deftest lambda.9
  ((lambda (x y) (declare (ignore x)) "foo" (declare (ignore y)) "bar") 1 2)
  "bar")

(deftest lambda.15
  ((lambda (y &optional (x (1+ y))) (list y x)) 10)
  (10 11))

(deftest lambda.16
  ((lambda (y &optional (x (1+ y))) (list y x)) 10 14)
  (10 14))

(deftest lambda.19
  (let ((b 10))
    ((lambda (&optional (a b) (b (1+ a))) (list a b)) 3))
  (3 4))

(deftest lambda.21
  (flet ((%f () (locally (declare (special *x*)) (incf *x*))))
    ((lambda (*x*)
       (declare (special *x*))
       (%f)
       *x*)
     10))
  11)

(deftest lambda.22
  (flet ((%f () (locally (declare (special *x*)) (1+ *x*))))
    ((lambda (*x*)
       (declare (special *x*))
       (%f))
     15))
  16)

(deftest lambda.27
  ((lambda (&key) 'good) :allow-other-keys nil)
  good)

(deftest lambda.28
  ((lambda (&key) 'good) :allow-other-keys t :foo t)
  good)

(deftest lambda.29
  ((lambda (&key) 'good) :allow-other-keys t :allow-other-keys nil :foo t)
  good)

(deftest lambda.30
  ((lambda (&key x) x) :allow-other-keys t :x 10
   :allow-other-keys nil :foo t)
  10)

(deftest lambda.32
  ((lambda (&rest x &key) x) :allow-other-keys nil)
  (:allow-other-keys nil))

(deftest lambda.33
  ((lambda (&rest x &key) x) :w 5 :allow-other-keys t :x 10)
  (:w 5 :allow-other-keys t :x 10))

(deftest lambda.36
  ((lambda (&key (a 1 a-p) (b 2 b-p) (c 3 c-p)) (list a (notnot a-p)
                                                      b (notnot b-p)
                                                      c (notnot c-p)))
   :c 5 :a 0 :allow-other-keys t 'b 100)
  (0 t 2 nil 5 t))

(deftest lambda.39
  (let ((a-p :bad))
    (declare (ignorable a-p))
    ((lambda (&key (a nil a-p) (b a-p)) (list a (notnot a-p) (notnot b)))))
  (nil nil nil))

(deftest lambda.40
  (let ((a-p :bad))
    (declare (ignorable a-p))
    ((lambda (&key (a nil a-p) (b a-p)) (list a (notnot a-p) (notnot b)))
     :a 1))
  (1 t t))

(deftest lambda.41
  (let ((a-p :bad))
    (declare (ignorable a-p))
    ((lambda (&key (a nil a-p) (b a-p)) (list a (notnot a-p) (notnot b)))
     :a nil))
  (nil t t))

(deftest lambda.44
  ((lambda (&key a b &allow-other-keys) (list a b)) :z 10 :b 2 :b nil :a 1
   :a 2 'x 100)
  (1 2))

(deftest lambda.45
  ((lambda (&key a b &allow-other-keys) (list a b)) :allow-other-keys nil
   :z 10 :b 2 :b nil :a 1 :a 2 'x 100)
  (1 2))

(deftest lambda.46
  ((lambda (&key a b allow-other-keys) (list allow-other-keys a b))
   :allow-other-keys nil :a 1 :b 2)
  (nil 1 2))

(deftest lambda.47
  ((lambda (&key a b allow-other-keys) (list allow-other-keys a b))
   :c 10 :allow-other-keys t :a 1 :b 2 :d 20)
  (t 1 2))

(deftest lambda.48
  ((lambda (&key a b allow-other-keys &allow-other-keys)
     (list allow-other-keys a b))
   :d 40 :allow-other-keys nil :a 1 :b 2 :c 20)
  (nil 1 2))

(deftest lambda.50
  ((lambda (&key a b ((:allow-other-keys aok)))
     (list aok a b))
   :d 40 :a 1 :allow-other-keys t :b 2 :c 20)
  (t 1 2))

(deftest lambda.52
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      ((lambda (&optional (y x)) (declare (special x)) y))))
  :good)

(deftest lambda.53
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      ((lambda (&key (y x)) (declare (special x)) y))))
  :good)

(deftest lambda.54
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      ((lambda (&aux (y x)) (declare (special x)) y))))
  :good)

(deftest lambda.57
  ((lambda (#1=#:foo) #1#) 17)
  17)

(deftest lambda.58
  ((lambda (&rest #1=#:foo) #1#) 'a 'b 'c)
  (a b c))

(deftest lambda.59
  ((lambda (&optional #1=#:foo) #1#))
  nil)

(deftest lambda.60
  ((lambda (&optional (#1=#:foo t)) #1#))
  t)

(deftest lambda.61
  ((lambda (&optional (#1=#:foo t)) #1#) 'bar)
  bar)

(deftest lambda.62
  ((lambda (&key #1=#:foo) #1#) :foo 12)
  12)

(deftest lambda.63
  (let ((y :bad1))
    (declare (ignore y))
    (let ((y :bad2))
      (declare (special y))
      (flet ((%f () y))
        ((lambda (x &aux (y :good))
           (declare (special y) (ignore x))
           (%f))
         nil))))
  :good)

(deftest lambda.64
  (let ((x :bad))
    (declare (special x))
    (flet ((%f () x))
      ((lambda (x &aux (y (%f)))
         (declare (type t y) (special x))
         y)
       :good)))
  :good)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
FLET:

(deftest flet.7
  (flet ((%f (x) x))
    (flet ((%f (y) (%f 20)))
      (%f 15)))
  20)

;;; Odd # of keyword args should throw a program-error in safe code
;;; (section 3.5.1.6)
(deftest flet.13
  (signals-error
   (flet ((%f (&key a (b 0 b-p)) (values a b (not (not b-p))))) (%f :a))
   program-error)
  t)

NOTE: The below works, but can we print the error better???
(deftest flet.16
  (signals-error (flet ((%f (&key a) a)) (%f '(foo))) program-error)
  t)

(deftest flet.17
  (flet (((setf %f) (x y) (setf (car y) x)))
    (let ((z (list 1 2)))
      (setf (%f z) 'a)
      z))
  (a 2))

(deftest flet.21
  (flet ((%f (x)
             (declare (type fixnum x))
             "Add one to the fixnum x."
             (1+ x)))
    (declare (ftype (function (fixnum) integer) %f))
    (%f 10))
  11)

(deftest flet.26
  (flet ((%f (x &optional (y 1 y-p) (z 2 z-p) &rest r &key foo bar)
             (list x y (not (not y-p)) z (not (not z-p)) r foo bar)))
    (values (%f 10) (%f 20 40) (%f 'a 'b 'c)
            (%f 'd 'e 'f :foo 'h :whatever nil :allow-other-keys t)
            (%f 'd 'e 'f :bar 'i :illegal t :foo 'z :allow-other-keys t) ))
  (10 1 nil 2 nil nil nil nil)
  (20 40 t 2 nil nil nil nil)
  (a b t c t nil nil nil)
  (d e t f t (:foo h :whatever nil :allow-other-keys t) h nil)
  (d e t f t (:bar i :illegal t :foo z :allow-other-keys t) z i))

;;; Section 3.4.1.4.1: "The :allow-other-keys argument is permissible
;;; in all situations involving keyword[2] arguments, even when its
;;; associated value is false."
(deftest flet.27
  (flet ((%f (x &optional (y 1 y-p) (z 2 z-p) &rest r &key foo bar)
             (list x y (not (not y-p)) z (not (not z-p)) r foo bar)))
    (values (%f 10) (%f 20 40) (%f 'a 'b 'c)
            (%f 'd 'e 'f :foo 'h :allow-other-keys nil)
            (%f 'd 'e 'f :bar 'i :allow-other-keys nil) ))
  (10 1 nil 2 nil nil nil nil)
  (20 40 t 2 nil nil nil nil)
  (a b t c t nil nil nil)
  (d e t f t (:foo h :allow-other-keys nil) h nil)
  (d e t f t (:bar i :allow-other-keys nil) nil i))

(deftest flet.28
  (flet ((%f (x &optional (y 1 y-p) (z 2 z-p) &rest r
                &key foo bar allow-other-keys)
             (list x y (not (not y-p)) z (not (not z-p)) allow-other-keys
                   r foo bar)))
    (values (%f 10) (%f 20 40) (%f 'a 'b 'c)
            (%f 'd 'e 'f :foo 'h :whatever nil :allow-other-keys 100)
            (%f 'd 'e 'f :bar 'i :illegal t :foo 'z :allow-other-keys 200) ))
  (10 1 nil 2 nil nil nil nil nil)
  (20 40 t 2 nil nil nil nil nil)
  (a b t c t nil nil nil nil)
  (d e t f t 100 (:foo h :whatever nil :allow-other-keys 100) h nil)
  (d e t f t 200 (:bar i :illegal t :foo z :allow-other-keys 200) z i))

(deftest flet.29
  (flet ((%f (x &optional (y 1 y-p) (z 2 z-p) &rest r
                &key foo bar allow-other-keys &allow-other-keys)
             (list x y (not (not y-p)) z (not (not z-p)) allow-other-keys
                   r foo bar)))
    (values (%f 10) (%f 20 40) (%f 'a 'b 'c)
            (%f 'd 'e 'f :foo 'h :whatever nil :allow-other-keys nil :blah t)
            (%f 'd 'e 'f :bar 'i :illegal t :foo 'z
                :allow-other-keys nil :zzz 10) ))
  (10 1 nil 2 nil nil nil nil nil)
  (20 40 t 2 nil nil nil nil nil)
  (a b t c t nil nil nil nil)
  (d e t f t nil (:foo h :whatever nil :allow-other-keys nil :blah t) h nil)
  (d e t f t nil (:bar i :illegal t :foo z :allow-other-keys nil :zzz 10) z i))

;;; Tests of non-keyword keywords (see section 3.4.1.4, paragrph 2).
(deftest flet.30
  (flet ((%f (&key ((foo bar) nil)) bar))
    (values (%f) (%f 'foo 10)))
  nil 10)

;;; Binding of formal parameters that are also special variables
(deftest flet.35
  (let ((x 'bad))
    (declare (special x))
    (flet ((%f () x))
      (flet ((%g (x)
                 (declare (special x))
                 (%f)))
        (%g 'good))))
  good)

(deftest flet.36
  (let ((x 'bad))
    (declare (special x))
    (flet ((%f () x))
      (flet ((%g (&aux (x 'good))
                 (declare (special x))
                 (%f)))
         (%g))))
  good)

(deftest flet.37
  (let ((x 'bad))
    (declare (special x))
    (flet ((%f () x))
      (flet ((%g (&rest x)
                 (declare (special x))
                 (%f)))
         (%g 'good))))
  (good))

(deftest flet.38
  (let ((x 'bad))
    (declare (special x))
    (flet ((%f () x))
      (flet ((%g (&key (x 'good))
                 (declare (special x))
                 (%f)))
         (%g))))
  good)

(deftest flet.39
  (let ((x 'bad))
    (declare (special x))
    (flet ((%f () x))
      (flet ((%g (&key (x 'bad))
                 (declare (special x))
                 (%f)))
         (%g :x 'good))))
  good)

;;; Keywords can be function names
(deftest flet.47
  (flet ((:foo () 'bar)) (:foo))
  bar)

(deftest flet.48
  (flet ((:foo () 'bar)) (funcall #':foo))
  bar)

;;; Check that nil keyword arguments do not enable the default values

(deftest flet.54
  (flet ((%f (&key (a 'wrong a-p)) (list a (not a-p)))) (%f :a nil))
  (nil nil))

(deftest flet.56
  (flet ((%f (&key ((:a b) 'wrong present?)) (list b (not present?)))) (%f :a nil))
  (nil nil))

(deftest flet.57
  (flet ((%f (&key) 'good))
    (%f :allow-other-keys nil))
  good)

(deftest flet.58
  (flet ((%f (&key) 'good))
    (%f :allow-other-keys t))
  good)

(deftest flet.59
  (flet ((%f (&key) 'good))
    (%f :allow-other-keys t :a 1 :b 2))
  good)

(deftest flet.62
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (flet ((%f (&optional (y x))
                 (declare (special x))
                 y))
        (%f))))
  :good)

(deftest flet.63
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (flet ((%f (&key (y x))
                 (declare (special x))
                 y))
        (%f))))
  :good)

(deftest flet.65
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (flet ((%f () (declare (special x)))))
      x))
  :good)

(deftest flet.66
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (flet ((%f () (declare (special x))))
        x)))
  :good)

(deftest flet.67
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (flet ((%f (&aux (y x))
                 (declare (special x))
                 y))
        (%f))))
  :good)

(deftest flet.69
  (let ((*x* 0))
    (declare (special *x*))
    (flet ((%f (i)
               #'(lambda (arg)
                   (declare (ignore arg))
                   (setq *x* i))))
      (values
       (funcall (%f 1) '(a b c))
       (funcall (%f 2) '(a b c))))))
  1 2)

// TODO: These next two need to be tested when we support macro-lambdas and compiler-macros.
(defmacro flet.73 () :bad)
(deftest flet.73
   (flet ((flet.73 () :good))
     (flet.73))
   :good)

(define-compiler-macro flet.74 (&whole form) :bad)
(deftest flet.74
   (flet ((flet.74 () :good))
     (flet.74))
   :good)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
LABELS:

// NOTE: Just need to figure out how to test this...
;;; The function is visible inside itself
(deftest labels.7
  (labels ((%f (x n) (cond ((eql n 0) x)
                           (t (%f (+ x n) (1- n))))))
    (%f 0 10))
  55)

// NOTE: for the next 2, &AUX works fine, but these don't. Use of LET for &AUX the reason why? Should we be using a LET for all init forms instead of SETQ'ing them? hmm....

;;; Scope of defined function names includes &OPTIONAL parameters
(deftest labels.7c
  (labels ((%f (x &optional (b (%g x))) b)
           (%g (y) (+ y y)))
    (%f 10))
  20)

;;; Scope of defined function names includes &KEY parameters
(deftest labels.7d
  (labels ((%f (x &key (b (%g x))) b)
           (%g (y) (+ y y)))
    (%f 10))
  20)

;;; Odd # of keyword args should throw a program-error in safe code
;;; (section 3.5.1.6)
(deftest labels.13
  (signals-error
   (labels ((%f (&key a (b 0 b-p)) (values a b (not (not b-p))))) (%f :a))
   program-error)
  t)

// NOTE: the following works, but can we print the message better???
;;; Invalid keyword argument (section 3.5.1.5)
(deftest labels.16
  (signals-error (labels ((%f (&key a) a)) (%f '(foo)))
                 program-error)
  t)

(deftest labels.17
  (labels (((setf %f) (x y) (setf (car y) x)))
    (let ((z (list 1 2)))
      (setf (%f z) 'a)
      z))
  (a 2))

;;; Declarations and documentation strings are ok
(deftest labels.21
  (labels ((%f (x)
             (declare (type fixnum x))
             "Add one to the fixnum x."
             (1+ x)))
    (declare (ftype (function (fixnum) integer) %f))
    (%f 10))
  11)

;;; Keywords can be function names
(deftest labels.22
  (labels ((:foo () 10)
           (:bar () (1+ (:foo))))
    (:bar))
  11)

(deftest labels.23
  (labels ((:foo () 10)
           (:bar () (1+ (funcall #':foo))))
    (funcall #':bar))
  11)

(deftest labels.29
  (labels ((%f (&key (a 'wrong a-p)) (list a (not a-p)))) (%f :a nil))
  (nil nil))

(deftest labels.31
  (labels ((%f (&key ((:a b) 'wrong present?)) (list b (not present?))))
    (%f :a nil))
  (nil nil))

(deftest labels.32
  (labels ((%f (&key) 'good))
    (%f :allow-other-keys nil))
  good)

(deftest labels.33
  (labels ((%f (&key) 'good))
    (%f :allow-other-keys t))
  good)

(deftest labels.34
  (labels ((%f (&key) 'good))
    (%f :allow-other-keys t :a 1 :b 2))
  good)

;;; Test that free declarations do not affect argument forms

(deftest labels.41
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (labels ((%f (&optional (y x))
                   (declare (special x))
                   y))
        (%f))))
  :good)

(deftest labels.42
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (labels ((%f (&key (y x))
                   (declare (special x))
                   y))
        (%f))))
  :good)

(deftest labels.44
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (labels ((%f () (declare (special x)))))
      x))
  :good)

(deftest labels.45
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (labels ((%f () (declare (special x))))
        x)))
  :good)

(deftest labels.46
  (let ((x :bad))
    (declare (special x))
    (let ((x :good))
      (labels ((%f (&aux (y x))
                   (declare (special x))
                   y))
        (%f))))
  :good)

// TODO: These next two need to be tested when we support macro-lambdas and compiler-macros.
(defmacro labels.51 () :bad)
(deftest labels.51
   (labels ((labels.51 () :good))
      (labels.51))
   :good)

(define-compiler-macro labels.52 (&whole form) :bad)
(deftest labels.52
   (labels ((labels.52 () :good))
     (labels.52))
   :good)
