UNWIND-PROTECT:

(deftest unwind-protect.6
  (let ((x nil))
    (block done
      (flet ((%f () (return-from done nil)))
        (unwind-protect (%f)
          (setq x '(a)))))
    x)
  (a))

(deftest unwind-protect.7
  (let ((x nil))
    (block done
      (flet ((%f () (return-from done nil)))
        (unwind-protect
            (unwind-protect (%f)
              (setq x '(b)))
          (setq x '(a)))))
    x)
  (a b))

(deftest unwind-protect.8
  (let ((x nil))
    (block done
      (unwind-protect
          (flet ((%f () (return-from done nil)))
            (unwind-protect
                (unwind-protect (%f)
                  (setq x '(b)))
              (setq x '(a))))
        (setq x '(c))))
    x)
  (c a b))

(deftest unwind-protect.9
  (let ((x nil))
    (handler-case
      (flet ((%f () (error 'type-error :datum 'foo :expected-type nil)))
        (unwind-protect (handler-case (%f))
          (setq x '(a))))
      (type-error () x)))
  (a))

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
TAGBODY:

(deftest tagbody.8
  (let ((x 0))
    (tagbody
     (flet ((%f (y) (setq x y) (go a)))
       (%f 10))
     (setq x 1)
     a)
    x)
  10)

(deftest tagbody.9
  (let (result)
    (tagbody
     (flet ((a (x) x))
       (setq result (a 10))
       (go a))
     a)
    result)
  10)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
BLOCK:

(deftest block.10
  (block done
    (flet ((%f (x) (return-from done x)))
      (block done (mapcar #'%f '(good bad bad))))
    'bad)
  good)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
THROW:

(deftest throw-error
  (signals-error (throw (gensym) nil) control-error)
  t)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
PROGV:

(deftest progv.1
  (progv () () t)
  t)

(progv (x) (1) x)
> Error: While compiling an anonymous function :
>        In the form (1), 1 is not a symbol or lambda expression., in process Listener(4).

(let ((x 0) (y 0) (c 0))
    (progv
        (progn (setq x (setq c 1)) nil)
        (progn (setq y (setq c 2)) nil)
      (values x y c)))

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
LET:

(deftest let.5
  (let ((x 0))
    (let ((#:x 1))
      x))
  0)

// TODO: strip out comment structs in the evaluator!!!
(deftest let.17a
  (funcall
   (compile
    nil
    '(lambda ()
       (let ((x :bad))
         (declare (special x))
         (let ((x :good)) ;; lexical binding
           (let ((y x))
             (declare (special x)) ;; free declaration
             y))))))
  :good)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
LET*:

(deftest let*.5
  (let* ((x 0))
    (let* ((#:x 1))
      x))
  0)

NOTE: This works fine, but we need to strip out CommentStructs at some point in the mix.
(deftest let*.17
  (let ((x :bad))
    (declare (special x))
    (let ((x :good)) ;; lexical binding
      (let* ((y x))
        (declare (special x)) ;; free declaration
        y)))
  :good)

(deftest let*.17a
  (funcall
   (compile
    nil
    '(lambda ()
       (let ((x :bad))
         (declare (special x))
         (let ((x :good)) ;; lexical binding
           (let* ((y x))
             (declare (special x)) ;; free declaration
             y))))))
  :good)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
LAMBDA:

(deftest lambda.63
  (let ((y :bad1))
    (declare (ignore y))
    (let ((y :bad2))
      (declare (special y))
      (flet ((%f () y))
        ((lambda (x &aux (y :good))
           (declare (special y) (ignore x))
           (%f))
         nil))))
  :good)

// The below works. Why should the above one work??? Hmm...
(deftest lambda.63
  (let ((y :bad1))
    (declare (ignore y))
    (let ((y :bad2))
      (declare (special y))
      (flet ((%f () (declare (special y)) y))
        ((lambda (x &aux (y :good))
           (declare (special y) (ignore x))
           (%f))
         nil))))
  :good)

(deftest lambda.57
  ((lambda (#1=#:foo) #1#) 17)
  17)

(deftest lambda.58
  ((lambda (&rest #1=#:foo) #1#) 'a 'b 'c)
  (a b c))

(deftest lambda.59
  ((lambda (&optional #1=#:foo) #1#))
  nil)

(deftest lambda.60
  ((lambda (&optional (#1=#:foo t)) #1#))
  t)

(deftest lambda.61
  ((lambda (&optional (#1=#:foo t)) #1#) 'bar)
  bar)

(deftest lambda.62
  ((lambda (&key #1=#:foo) #1#) :foo 12)
  12)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
FLET:

(deftest flet.7
  (flet ((%f (x) x))
    (flet ((%f (y) (%f 20)))
      (%f 15)))
  20)

NOTE: The below works, but can we print the error better???
(deftest flet.13
  (signals-error
   (flet ((%f (&key a (b 0 b-p)) (values a b b-p))) (%f :a))
   program-error)
  t)

NOTE: The below works, but can we print the error better???
(deftest flet.16
  (signals-error (flet ((%f (&key a) a)) (%f '(foo))) program-error)
  t)

(deftest flet.17
  (flet (((setf %f) (x y) (setf (car y) x)))
    (let ((z (list 1 2)))
      (setf (%f z) 'a)
      z))
  (a 2))

(deftest flet.69
  (let ((*x* 0))
    (declare (special *x*))
    (flet ((%f (i)
               #'(lambda (arg)
                   (declare (ignore arg))
                   (setq *x* (1+ i)))))
      (values
       (funcall (%f 1) nil)
       (funcall (%f 2) nil))))
  2 3)

// TODO: These next two need to be tested when we support macro-lambdas and compiler-macros.
(defmacro flet.73 () :bad)
(deftest flet.73
   (flet ((flet.73 () :good))
     (flet.73))
   :good)

(define-compiler-macro flet.74 (&whole form) :bad)
(deftest flet.74
   (flet ((flet.74 () :good))
     (flet.74))
   :good)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
LABELS:

// NOTE: Just need to figure out how to test this...
;;; The function is visible inside itself
(deftest labels.7
  (labels ((%f (x n) (cond ((eql n 0) x)
                           (t (%f (+ x n) (1- n))))))
    (%f 0 10))
  55)

// NOTE: the following works, but can we print the message better???
(deftest labels.13
  (signals-error
   (labels ((%f (&key a (b 0 b-p)) (values a b b-p))) (%f :a))
   program-error)
  t)

// NOTE: the following works, but can we print the message better???
;;; Invalid keyword argument (section 3.5.1.5)
(deftest labels.16
  (signals-error (labels ((%f (&key a) a)) (%f '(foo)))
                 program-error)
  t)

(deftest labels.17
  (labels (((setf %f) (x y) (setf (car y) x)))
    (let ((z (list 1 2)))
      (setf (%f z) 'a)
      z))
  (a 2))

// TODO: These next two need to be tested when we support macro-lambdas and compiler-macros.
(defmacro labels.51 () :bad)
(deftest labels.51
   (labels ((labels.51 () :good))
      (labels.51))
   :good)

(define-compiler-macro labels.52 (&whole form) :bad)
(deftest labels.52
   (labels ((labels.52 () :good))
     (labels.52))
   :good)
